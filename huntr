#!/usr/bin/env bash

# =============================================================================
# TOOL INFORMATION & GLOBAL VARIABLES
# =============================================================================

# Tool Information
TOOL_NAME="Huntr"
TOOL_VERSION="0.1.2" # This will be compared against the GitHub release version
DEVELOPER="0xb0rn3 | 0xbv1"
DEVELOPER_IG="theehiv3"
GITHUB_REPO="0xb0rn3/huntr"
GITHUB_URL="https://github.com/${GITHUB_REPO}"

# Color codes for better user experience
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script Path Information
SCRIPT_NAME="$(basename "$0")"
SCRIPT_PATH="$(realpath "$0")"

# Update check configuration
UPDATE_CHECK_URL="https://api.github.com/repos/${GITHUB_REPO}/releases/latest"

# System-wide installation paths
SYSTEM_INSTALL_DIR="/usr/local/bin"
SYSTEM_CONFIG_DIR="/etc/huntr"
USER_CONFIG_DIR="$HOME/.config/huntr"
INSTALL_SCRIPT_NAME="huntr"

# Update and installation URLs
MAIN_SCRIPT_URL="https://raw.githubusercontent.com/${GITHUB_REPO}/main/$(basename "$0")"
V6_MODULE_URL="https://raw.githubusercontent.com/${GITHUB_REPO}/main/.v6module"
INSTALL_SCRIPT_URL="https://raw.githubusercontent.com/${GITHUB_REPO}/main/install.sh"

# Global variables to track tool availability
HAVE_NMAP=false
HAVE_FPING=false
HAVE_MASSCAN=false
HAVE_HPING3=false

# Load v6module if available (checking multiple paths)
V6_MODULE_AVAILABLE=false
V6_MODULE_PATHS=("$SYSTEM_CONFIG_DIR/.v6module" "$(dirname "$SCRIPT_PATH")/.v6module" "./.v6module")

for v6_path in "${V6_MODULE_PATHS[@]}"; do
    if [[ -f "$v6_path" ]]; then
        source "$v6_path"
        V6_MODULE_AVAILABLE=true
        echo -e "${GREEN}‚úÖ v6module loaded from $v6_path${NC}"
        break
    fi
done

if [ "$V6_MODULE_AVAILABLE" = false ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  v6module not found. Advanced features disabled.${NC}"
fi

# Enhanced stealth configuration variables
STEALTH_MODE=false
RANDOMIZE_ORDER=true
DECOY_COUNT=3
MIN_DELAY=0.1
MAX_DELAY=0.5

# Nmap optimization variables
NMAP_PARALLEL_MIN=10
NMAP_PARALLEL_MAX=50
NMAP_HOST_TIMEOUT="3s"
NMAP_DISCOVERY_PROBES=4


# =============================================================================
# ENHANCED UPDATE & INSTALLATION FUNCTIONS
# =============================================================================

# Enhanced version comparison with better error handling
version_compare_enhanced() {
    local version1="$1"
    local version2="$2"

    # Remove 'v' prefix and handle empty versions
    version1=$(echo "$version1" | sed 's/^v//' | sed 's/^$/0.0.0/')
    version2=$(echo "$version2" | sed 's/^v//' | sed 's/^$/0.0.0/')

    # Split versions into arrays
    IFS='.' read -ra v1_parts <<< "$version1"
    IFS='.' read -ra v2_parts <<< "$version2"

    # Pad arrays to same length (handle pre-release versions)
    local max_length=3
    if [ ${#v1_parts[@]} -gt $max_length ]; then max_length=${#v1_parts[@]}; fi
    if [ ${#v2_parts[@]} -gt $max_length ]; then max_length=${#v2_parts[@]}; fi

    # Compare each part
    for ((i=0; i<max_length; i++)); do
        local part1=${v1_parts[i]:-0}
        local part2=${v2_parts[i]:-0}

        # Handle non-numeric parts (like alpha, beta, rc)
        if [[ ! "$part1" =~ ^[0-9]+$ ]] || [[ ! "$part2" =~ ^[0-9]+$ ]]; then
            if [ "$part1" \< "$part2" ]; then
                echo "less"
                return
            elif [ "$part1" \> "$part2" ]; then
                echo "greater"
                return
            fi
        else
            if [ "$part1" -lt "$part2" ]; then
                echo "less"
                return
            elif [ "$part1" -gt "$part2" ]; then
                echo "greater"
                return
            fi
        fi
    done

    echo "equal"
}

# Enhanced update check with better error handling and logging
check_for_updates_enhanced() {
    local silent_mode="$1"
    local force_check="$2"

    if [ "$silent_mode" != "silent" ]; then
        echo -e "${BLUE}üîÑ Checking for updates from ${GITHUB_URL}...${NC}"
    fi

    # Check network connectivity with multiple fallbacks
    local network_ok=false
    for dns in "8.8.8.8" "1.1.1.1" "9.9.9.9"; do
        if ping -c 1 -W 3 "$dns" &> /dev/null; then
            network_ok=true
            break
        fi
    done

    if [ "$network_ok" = false ]; then
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  No internet connection. Cannot check for updates.${NC}"
        fi
        return 1
    fi

    # Check if required tools are available
    if ! command -v curl &> /dev/null; then
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  curl not found. Cannot check for updates.${NC}"
        fi
        return 1
    fi

    # Create temporary file for API response
    local temp_response=$(mktemp)
    local api_response

    # Fetch latest release with enhanced error handling
    if curl -s --connect-timeout 10 --max-time 30 \
            -H "Accept: application/vnd.github.v3+json" \
            -H "User-Agent: huntr-updater/1.0" \
            "$UPDATE_CHECK_URL" > "$temp_response" 2>/dev/null; then

        api_response=$(cat "$temp_response")
        rm -f "$temp_response"

        if [ -z "$api_response" ]; then
            if [ "$silent_mode" != "silent" ]; then
                echo -e "${YELLOW}‚ö†Ô∏è  Empty response from GitHub API.${NC}"
            fi
            return 1
        fi
    else
        rm -f "$temp_response"
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Failed to fetch update information from GitHub.${NC}"
        fi
        return 1
    fi

    # Parse latest version with multiple fallback methods
    local latest_version
    if command -v jq &> /dev/null; then
        latest_version=$(echo "$api_response" | jq -r '.tag_name' 2>/dev/null)
    elif command -v python3 &> /dev/null; then
        latest_version=$(echo "$api_response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('tag_name', ''))" 2>/dev/null)
    else
        # Fallback to grep/sed parsing with improved regex
        latest_version=$(echo "$api_response" | grep -o '"tag_name"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"tag_name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
    fi

    if [ -z "$latest_version" ] || [ "$latest_version" = "null" ]; then
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Unable to parse version information from GitHub.${NC}"
        fi
        return 1
    fi

    # Compare versions using enhanced function
    local comparison=$(version_compare_enhanced "$TOOL_VERSION" "$latest_version")

    case $comparison in
        "less")
            echo -e "${GREEN}üÜï New version available: $latest_version (current: $TOOL_VERSION)${NC}"
            if [ "$silent_mode" != "silent" ]; then
                echo -e "${CYAN}üìã Release notes: ${GITHUB_URL}/releases/tag/$latest_version${NC}"
            fi
            return 0  # Update available
            ;;
        "equal")
            if [ "$silent_mode" != "silent" ]; then
                echo -e "${GREEN}‚úÖ Running latest version ($TOOL_VERSION)${NC}"
            fi
            return 2  # Already latest
            ;;
        "greater")
            if [ "$silent_mode" != "silent" ]; then
                echo -e "${CYAN}üß™ Running development version ($TOOL_VERSION > $latest_version)${NC}"
            fi
            return 2  # Development version
            ;;
    esac

    return 1  # Error case
}

# Enhanced update function with v6module support
perform_update_enhanced() {
    echo -e "${BLUE}üîÑ Starting enhanced update process...${NC}"

    # Detect if we're running system-wide installation
    local is_system_install=false
    local script_location=""
    local config_location=""

    if [[ "$SCRIPT_PATH" == "/usr/local/bin/"* ]] || [[ "$SCRIPT_PATH" == "/usr/bin/"* ]]; then
        is_system_install=true
        script_location="$SYSTEM_INSTALL_DIR/$INSTALL_SCRIPT_NAME"
        config_location="$SYSTEM_CONFIG_DIR"
        echo -e "${CYAN}üìç Detected system-wide installation${NC}"
    else
        script_location="$SCRIPT_PATH"
        config_location="$(dirname "$SCRIPT_PATH")"
        echo -e "${CYAN}üìç Detected local installation${NC}"
    fi

    # Create temporary directory for downloads
    local temp_dir=$(mktemp -d)
    local temp_script="$temp_dir/$(basename "$script_location")"
    local temp_v6module="$temp_dir/.v6module"

    echo -e "${CYAN}üì• Downloading latest version...${NC}"

    # Download main script
    if curl -s --connect-timeout 10 --max-time 60 \
            -H "Cache-Control: no-cache" \
            -o "$temp_script" "$MAIN_SCRIPT_URL"; then

        # Verify main script download
        if [ -s "$temp_script" ] && head -1 "$temp_script" | grep -q "#!/usr/bin/env bash"; then
            echo -e "${GREEN}‚úÖ Main script downloaded successfully${NC}"
            chmod +x "$temp_script"
        else
            echo -e "${RED}‚ùå Downloaded main script appears to be invalid${NC}"
            rm -rf "$temp_dir"
            return 1
        fi
    else
        echo -e "${RED}‚ùå Failed to download main script${NC}"
        rm -rf "$temp_dir"
        return 1
    fi

    # Download v6module if it exists locally or user wants it
    local update_v6module=false
    if [[ -f "$(dirname "$SCRIPT_PATH")/.v6module" ]] || [[ -f "$config_location/.v6module" ]]; then
        update_v6module=true
        echo -e "${CYAN}üì• Downloading v6module...${NC}"
    elif [ "$is_system_install" = false ]; then
        read -p "Download v6module for enhanced features? (y/N): " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            update_v6module=true
            echo -e "${CYAN}üì• Downloading v6module...${NC}"
        fi
    fi

    if [ "$update_v6module" = true ]; then
        if curl -s --connect-timeout 10 --max-time 30 \
                -H "Cache-Control: no-cache" \
                -o "$temp_v6module" "$V6_MODULE_URL"; then

            if [ -s "$temp_v6module" ]; then
                echo -e "${GREEN}‚úÖ v6module downloaded successfully${NC}"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  v6module download failed, continuing without it${NC}"
                rm -f "$temp_v6module"
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  v6module download failed, continuing without it${NC}"
            rm -f "$temp_v6module"
        fi
    fi

    # Create backup of current installation
    local backup_dir="$HOME/.huntr-backups/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    echo -e "${CYAN}üíæ Creating backup...${NC}"
    cp "$script_location" "$backup_dir/" 2>/dev/null
    if [[ -f "$config_location/.v6module" ]]; then
        cp "$config_location/.v6module" "$backup_dir/" 2>/dev/null
    fi
    echo -e "${GREEN}‚úÖ Backup created: $backup_dir${NC}"

    # Perform update based on installation type
    if [ "$is_system_install" = true ]; then
        echo -e "${YELLOW}üîê System-wide update requires sudo privileges${NC}"

        # Update main script
        if sudo cp "$temp_script" "$script_location"; then
            echo -e "${GREEN}‚úÖ Main script updated successfully${NC}"
        else
            echo -e "${RED}‚ùå Failed to update main script${NC}"
            rm -rf "$temp_dir"
            return 1
        fi

        # Update v6module if needed
        if [[ -f "$temp_v6module" ]]; then
            sudo mkdir -p "$config_location"
            if sudo cp "$temp_v6module" "$config_location/.v6module"; then
                echo -e "${GREEN}‚úÖ v6module updated successfully${NC}"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  v6module update failed${NC}"
            fi
        fi

    else
        # Local installation update
        if cp "$temp_script" "$script_location"; then
            echo -e "${GREEN}‚úÖ Main script updated successfully${NC}"
        else
            echo -e "${RED}‚ùå Failed to update main script${NC}"
            rm -rf "$temp_dir"
            return 1
        fi

        # Update v6module if needed
        if [[ -f "$temp_v6module" ]]; then
            if cp "$temp_v6module" "$config_location/.v6module"; then
                echo -e "${GREEN}‚úÖ v6module updated successfully${NC}"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  v6module update failed${NC}"
            fi
        fi
    fi

    # Cleanup
    rm -rf "$temp_dir"

    echo -e "${GREEN}üéâ Update completed successfully!${NC}"
    echo -e "${CYAN}üìã Backup location: $backup_dir${NC}"
    echo -e "${CYAN}üîÑ Restarting with new version...${NC}"
    echo ""

    # Restart the script with the same arguments
    exec "$script_location" "$@"
}

# Check if running as system-wide installation
is_system_wide_install() {
    [[ "$SCRIPT_PATH" == "/usr/local/bin/"* ]] || [[ "$SCRIPT_PATH" == "/usr/bin/"* ]]
}

# Install system-wide with proper permissions and paths
install_system_wide() {
    echo -e "${BLUE}üîß Installing Huntr system-wide...${NC}"

    # Check if already installed system-wide
    if command -v huntr &> /dev/null && [[ "$(which huntr)" == "/usr/local/bin/huntr" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Huntr is already installed system-wide${NC}"
        read -p "Reinstall/update system installation? (y/N): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            return 0
        fi
    fi

    # Check for sudo privileges
    if ! sudo -n true 2>/dev/null; then
        echo -e "${YELLOW}üîê This operation requires sudo privileges${NC}"
        if ! sudo -v; then
            echo -e "${RED}‚ùå Cannot obtain sudo privileges${NC}"
            return 1
        fi
    fi

    # Create system directories
    echo -e "${CYAN}üìÅ Creating system directories...${NC}"
    sudo mkdir -p "$SYSTEM_INSTALL_DIR"
    sudo mkdir -p "$SYSTEM_CONFIG_DIR"

    # Copy main script
    echo -e "${CYAN}üìã Installing main script...${NC}"
    if sudo cp "$SCRIPT_PATH" "$SYSTEM_INSTALL_DIR/$INSTALL_SCRIPT_NAME"; then
        sudo chmod +x "$SYSTEM_INSTALL_DIR/$INSTALL_SCRIPT_NAME"
        echo -e "${GREEN}‚úÖ Main script installed${NC}"
    else
        echo -e "${RED}‚ùå Failed to install main script${NC}"
        return 1
    fi

    # Copy v6module if exists
    if [[ -f "$(dirname "$SCRIPT_PATH")/.v6module" ]]; then
        echo -e "${CYAN}üìã Installing v6module...${NC}"
        if sudo cp "$(dirname "$SCRIPT_PATH")/.v6module" "$SYSTEM_CONFIG_DIR/.v6module"; then
            echo -e "${GREEN}‚úÖ v6module installed${NC}"
        else
            echo -e "${YELLOW}‚ö†Ô∏è  v6module installation failed${NC}"
        fi
    else
        read -p "Download and install v6module for enhanced features? (y/N): " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo -e "${CYAN}üì• Downloading v6module...${NC}"
            local temp_v6=$(mktemp)
            if curl -s --connect-timeout 10 --max-time 30 -o "$temp_v6" "$V6_MODULE_URL"; then
                if sudo cp "$temp_v6" "$SYSTEM_CONFIG_DIR/.v6module"; then
                    echo -e "${GREEN}‚úÖ v6module downloaded and installed${NC}"
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  v6module installation failed${NC}"
                fi
            else
                echo -e "${YELLOW}‚ö†Ô∏è  v6module download failed${NC}"
            fi
            rm -f "$temp_v6"
        fi
    fi

    # Create user config directory
    mkdir -p "$USER_CONFIG_DIR"

    # Verify installation
    if command -v huntr &> /dev/null; then
        echo -e "${GREEN}üéâ System-wide installation completed successfully!${NC}"
        echo -e "${CYAN}üìç Installation location: $SYSTEM_INSTALL_DIR/$INSTALL_SCRIPT_NAME${NC}"
        echo -e "${CYAN}üìç Configuration location: $SYSTEM_CONFIG_DIR${NC}"
        echo -e "${CYAN}üöÄ You can now run 'huntr' from anywhere${NC}"
        echo ""
        echo -e "${BLUE}Testing installation...${NC}"
        huntr --version
        return 0
    else
        echo -e "${RED}‚ùå Installation verification failed${NC}"
        return 1
    fi
}

# Uninstall system-wide installation
uninstall_system_wide() {
    echo -e "${BLUE}üóëÔ∏è  Uninstalling Huntr system-wide installation...${NC}"

    if ! command -v huntr &> /dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Huntr is not installed system-wide${NC}"
        return 1
    fi

    # Confirm uninstallation
    echo -e "${YELLOW}‚ö†Ô∏è  This will remove Huntr from system-wide access${NC}"
    read -p "Are you sure you want to uninstall? (y/N): " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${CYAN}Uninstallation cancelled${NC}"
        return 0
    fi

    # Check for sudo privileges
    if ! sudo -v; then
        echo -e "${RED}‚ùå Cannot obtain sudo privileges${NC}"
        return 1
    fi

    # Create backup before uninstall
    local backup_dir="$HOME/.huntr-backups/uninstall_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    echo -e "${CYAN}üíæ Creating backup before uninstall...${NC}"
    cp "$SYSTEM_INSTALL_DIR/$INSTALL_SCRIPT_NAME" "$backup_dir/" 2>/dev/null
    cp "$SYSTEM_CONFIG_DIR/.v6module" "$backup_dir/" 2>/dev/null

    # Remove files
    echo -e "${CYAN}üóëÔ∏è  Removing system files...${NC}"
    sudo rm -f "$SYSTEM_INSTALL_DIR/$INSTALL_SCRIPT_NAME"
    sudo rm -rf "$SYSTEM_CONFIG_DIR"

    # Verify uninstallation
    if ! command -v huntr &> /dev/null; then
        echo -e "${GREEN}‚úÖ System-wide uninstallation completed${NC}"
        echo -e "${CYAN}üíæ Backup created: $backup_dir${NC}"
    else
        echo -e "${RED}‚ùå Uninstallation may have failed${NC}"
        return 1
    fi
}


# =============================================================================
# CORE TOOL FUNCTIONS
# =============================================================================

# Function to generate random MAC address for spoofing
generate_random_mac() {
    printf '02:%02x:%02x:%02x:%02x:%02x\n' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# Function to get random delay between probes
get_random_delay() {
    local min_delay=$1
    local max_delay=$2
    # Generate random delay between min and max (in seconds)
    echo "scale=2; $min_delay + ($max_delay - $min_delay) * $RANDOM / 32767" | bc -l 2>/dev/null || echo "$min_delay"
}

# Enhanced function to create intelligent decoy IP list
generate_smart_decoys() {
    local network_base="$1"
    local target_range_start="$2"
    local target_range_end="$3"
    local decoy_list=""

    # Create decoys that blend with the network topology
    for i in $(seq 1 $DECOY_COUNT); do
        local random_host

        # 70% chance to use nearby IPs (more realistic)
        if (( RANDOM % 10 < 7 )); then
            # Generate IP close to target range but outside it
            local range_size=$((target_range_end - target_range_start))
            local offset=$((RANDOM % (range_size * 2) + 1))

            if (( target_range_start - offset > 1 )); then
                random_host=$((target_range_start - offset))
            elif (( target_range_end + offset < 254 )); then
                random_host=$((target_range_end + offset))
            else
                random_host=$((RANDOM % 254 + 1))
            fi
        else
            # 30% chance for completely random (noise)
            random_host=$((RANDOM % 254 + 1))
        fi

        # Avoid common gateway/broadcast/multicast ranges
        while [[ $random_host -eq 1 || $random_host -eq 254 || $random_host -eq 255 ||
                 ($random_host -ge 224 && $random_host -le 239) ]]; do
            random_host=$((RANDOM % 254 + 1))
        done

        if [ -n "$decoy_list" ]; then
            decoy_list="${decoy_list},${network_base}.${random_host}"
        else
            decoy_list="${network_base}.${random_host}"
        fi
    done

    echo "$decoy_list"
}

# Advanced nmap host discovery with intelligent filtering
optimized_nmap_discovery() {
    local network_base="$1"
    local scan_type="$2"  # "stealth" or "fast"

    echo -e "${BLUE}üéØ Using advanced nmap host discovery with intelligent filtering...${NC}"

    local nmap_args=""
    local timing_template=""
    local discovery_method=""

    # Configure nmap based on scan type
    if [[ "$scan_type" == "stealth" ]]; then
        echo -e "${PURPLE}ü•∑ STEALTH MODE: Advanced evasion techniques enabled${NC}"

        # Generate smart decoys for the entire range
        local decoys=$(generate_smart_decoys "$network_base" 1 254)
        echo -e "${CYAN}Using intelligent decoy IPs: $decoys${NC}"

        timing_template="T1"
        discovery_method="-PE -PP -PM -PO"  # Multiple ICMP types for better coverage

        nmap_args="--randomize-hosts \
                            --data-length $((RANDOM % 32 + 16)) \
                            --ttl $((32 + RANDOM % 32)) \
                            -D $decoys \
                            --scan-delay $(get_random_delay 0.5 2.0) \
                            --max-parallelism $NMAP_PARALLEL_MIN \
                            --min-parallelism 5 \
                            -f \
                            --spoof-mac $(generate_random_mac) \
                            --host-timeout $NMAP_HOST_TIMEOUT"
    else
        echo -e "${GREEN}‚ö° FAST MODE: Optimized for speed and efficiency${NC}"

        timing_template="T4"
        discovery_method="-PE -PA80,443,22,21,25,53,135,139,445"  # TCP ACK to common ports

        nmap_args="--min-parallelism $NMAP_PARALLEL_MIN \
                            --max-parallelism $NMAP_PARALLEL_MAX \
                            --host-timeout $NMAP_HOST_TIMEOUT \
                            --max-retries 2"
    fi

    start_time=$(date +%s)

    # Execute nmap with intelligent output parsing
    echo -e "${CYAN}Discovery method: $discovery_method${NC}"
    echo -e "${CYAN}Timing template: $timing_template${NC}"
    echo ""

    # Use nmap's XML output for better parsing reliability
    local temp_xml=$(mktemp)
    local temp_results=$(mktemp)

    # Execute the nmap scan with comprehensive host discovery
    nmap -sn \
         -$timing_template \
         $discovery_method \
         $nmap_args \
         -oX "$temp_xml" \
         "${network_base}.1-254" 2>/dev/null

    # Parse XML output for more reliable results
    if command -v xmllint &> /dev/null; then
        # Use xmllint for precise XML parsing
        xmllint --xpath "//host[status/@state='up']/address[@addrtype='ipv4']/@addr" "$temp_xml" 2>/dev/null | \
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | \
        sort -V > "$temp_results"
    else
        # Fallback to grep/awk parsing with improved accuracy
        grep -E "<address addr=\"[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\" addrtype=\"ipv4\"/>" "$temp_xml" | \
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | \
        sort -V > "$temp_results"
    fi

    # Enhanced result processing with host information
    local host_count=0
    echo -e "${GREEN}üìã Active hosts discovered:${NC}"
    echo "----------------------------------------"

    while IFS= read -r ip_addr; do
        ((host_count++))

        # Get hostname if available from nmap results
        local hostname=""
        if grep -q "hostname.*name=\".*\".*type=\"PTR\"" "$temp_xml"; then
            hostname=$(grep -A5 -B5 "$ip_addr" "$temp_xml" | \
                                   grep -oE "hostname.*name=\"[^\"]*\"" | \
                                   head -1 | \
                                   sed 's/.*name="\([^"]*\)".*/\1/')
        fi

        # Display results with enhanced formatting
        if [[ -n "$hostname" && "$hostname" != "$ip_addr" ]]; then
            echo -e "${GREEN}üéØ $ip_addr${NC} ${CYAN}($hostname)${NC}"
        else
            echo -e "${GREEN}üéØ $ip_addr${NC}"
        fi

        # Add small delay in stealth mode to avoid burst patterns
        if [[ "$scan_type" == "stealth" ]]; then
            sleep $(get_random_delay 0.1 0.3)
        fi

    done < "$temp_results"

    # Cleanup temporary files
    rm -f "$temp_xml" "$temp_results"

    end_time=$(date +%s)
    scan_duration=$((end_time - start_time))

    echo "----------------------------------------"
    echo -e "${BLUE}üìä Scan Summary:${NC}"
    echo -e "${GREEN}‚Ä¢ Active hosts found: $host_count${NC}"
    echo -e "${GREEN}‚Ä¢ Scan duration: ${scan_duration}s${NC}"
    echo -e "${GREEN}‚Ä¢ Average time per host: $(echo "scale=2; $scan_duration / 254" | bc -l)s${NC}"

    if [[ "$scan_type" == "stealth" ]]; then
        echo -e "${PURPLE}‚Ä¢ Stealth techniques: Decoys, timing randomization, packet fragmentation${NC}"
    else
        echo -e "${CYAN}‚Ä¢ Optimization: Parallel processing, smart timeouts, multi-probe discovery${NC}"
    fi
}

# Ultra-stealth nmap with advanced evasion - IMPROVED VERSION
ultra_stealth_nmap() {
    local network_base="$1"
    optimized_nmap_discovery "$network_base" "stealth"
}

# Fast optimized nmap - IMPROVED VERSION
fast_nmap_discovery() {
    local network_base="$1"
    optimized_nmap_discovery "$network_base" "fast"
}

# Advanced nmap port discovery for found hosts
nmap_port_discovery() {
    local network_base="$1"
    local scan_type="$2"

    echo -e "${BLUE}üîç Performing port discovery on active hosts...${NC}"

    # First, get list of active hosts
    local temp_hosts=$(mktemp)
    local temp_xml=$(mktemp)

    # Quick host discovery first
    nmap -sn -T4 "${network_base}.1-254" -oX "$temp_xml" 2>/dev/null

    if command -v xmllint &> /dev/null; then
        xmllint --xpath "//host[status/@state='up']/address[@addrtype='ipv4']/@addr" "$temp_xml" 2>/dev/null | \
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" > "$temp_hosts"
    else
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" "$temp_xml" > "$temp_hosts"
    fi

    local host_count=$(wc -l < "$temp_hosts")

    if [[ $host_count -eq 0 ]]; then
        echo -e "${YELLOW}No active hosts found for port scanning${NC}"
        rm -f "$temp_hosts" "$temp_xml"
        return
    fi

    echo -e "${GREEN}Found $host_count active hosts. Starting port discovery...${NC}"
    echo ""

    # Configure port scan based on type
    local port_args=""
    local ports="22,23,25,53,80,110,135,139,443,445,993,995,1723,3389,5900"

    if [[ "$scan_type" == "stealth" ]]; then
        echo -e "${PURPLE}ü•∑ Stealth port discovery with SYN stealth scan${NC}"
        port_args="-sS -T2 --randomize-hosts -f"
    else
        echo -e "${GREEN}‚ö° Fast port discovery with connect scan${NC}"
        port_args="-sT -T4 --min-parallelism 20 --max-parallelism 100"
    fi

    # Scan each host for common ports
    while IFS= read -r host; do
        echo -e "${CYAN}Scanning $host for common services...${NC}"

        local port_results=$(mktemp)
        nmap $port_args -p "$ports" --open "$host" -oG "$port_results" 2>/dev/null

        # Parse and display open ports
        local open_ports=$(grep "Ports:" "$port_results" | \
                                   grep -oE "[0-9]+/open" | \
                                   cut -d'/' -f1 | \
                                   tr '\n' ',' | \
                                   sed 's/,$//')

        if [[ -n "$open_ports" ]]; then
            echo -e "${GREEN}  ‚îî‚îÄ Open ports: $open_ports${NC}"
        else
            echo -e "${YELLOW}  ‚îî‚îÄ No common ports open${NC}"
        fi

        rm -f "$port_results"

        # Small delay between hosts in stealth mode
        if [[ "$scan_type" == "stealth" ]]; then
            sleep $(get_random_delay 1.0 2.0)
        fi

    done < "$temp_hosts"

    rm -f "$temp_hosts" "$temp_xml"
}


# =============================================================================
# DEPENDENCY MANAGEMENT
# =============================================================================

# Function to detect dependencies including stealth tools
check_and_install_deps() {
    local pkg_manager
    local network_ok=true

    echo -e "${BLUE}=== Dependency Check & Auto-Installation ===${NC}"

    # Quick network check first
    echo -ne "${BLUE}Checking network connectivity...${NC}"
    if ping -c 1 -W 2 8.8.8.8 &> /dev/null || ping -c 1 -W 2 1.1.1.1 &> /dev/null; then
        echo -e " ${GREEN}‚úì Online${NC}"
        network_ok=true
    else
        echo -e " ${RED}‚úó Offline${NC}"
        echo -e "${YELLOW}Warning: No internet connection detected. Cannot install missing tools.${NC}"
        network_ok=false
    fi
    if $V6_MODULE_AVAILABLE; then
        init_v6_module
    fi
    # Detect package manager
    pkg_manager=$(detect_package_manager)
    if [ "$pkg_manager" = "unknown" ]; then
        echo -e "${YELLOW}Warning: Unknown package manager. Manual installation may be required.${NC}"
    fi

    # Check core tools with improved detection
    local tools=("nmap:nmap" "fping:fping" "masscan:masscan" "hping3:hping3" "bc:bc" "shuf:coreutils" "xmllint:libxml2-utils")

    for tool_info in "${tools[@]}"; do
        IFS=':' read -r tool package <<< "$tool_info"
        echo -ne "${BLUE}Checking $tool...${NC}"

        if command -v "$tool" &> /dev/null; then
            echo -e " ${GREEN}‚úì Found${NC}"
            case $tool in
                "nmap") HAVE_NMAP=true ;;
                "fping") HAVE_FPING=true ;;
                "masscan") HAVE_MASSCAN=true ;;
                "hping3") HAVE_HPING3=true ;;
            esac
        else
            echo -ne " ${YELLOW}Missing${NC}"
            if $network_ok && [ "$pkg_manager" != "unknown" ]; then
                echo -ne " - Installing..."
                if install_package "$package" "$pkg_manager"; then
                    echo -e " ${GREEN}‚úì Installed${NC}"
                    case $tool in
                        "nmap") HAVE_NMAP=true ;;
                        "fping") HAVE_FPING=true ;;
                        "masscan") HAVE_MASSCAN=true ;;
                        "hping3") HAVE_HPING3=true ;;
                    esac
                else
                    echo -e " ${RED}‚úó Failed${NC}"
                fi
            else
                echo -e " ${RED}‚úó Cannot install${NC}"
            fi
        fi
    done

    echo ""
}

# Function to detect the package manager and OS
detect_package_manager() {
    if command -v apt-get &> /dev/null; then
        echo "apt"
    elif command -v yum &> /dev/null; then
        echo "yum"
    elif command -v dnf &> /dev/null; then
        echo "dnf"
    elif command -v pacman &> /dev/null; then
        echo "pacman"
    elif command -v zypper &> /dev/null; then
        echo "zypper"
    elif command -v apk &> /dev/null; then
        echo "apk"
    else
        echo "unknown"
    fi
}

# Function to install a package based on the detected package manager
install_package() {
    local package_name="$1"
    local pkg_manager="$2"

    case $pkg_manager in
        "apt")
            sudo apt-get update &> /dev/null && sudo apt-get install -y "$package_name" &> /dev/null
            ;;
        "yum")
            sudo yum install -y "$package_name" &> /dev/null
            ;;
        "dnf")
            sudo dnf install -y "$package_name" &> /dev/null
            ;;
        "pacman")
            sudo pacman -Sy --noconfirm "$package_name" &> /dev/null
            ;;
        "zypper")
            sudo zypper install -y "$package_name" &> /dev/null
            ;;
        "apk")
            sudo apk add "$package_name" &> /dev/null
            ;;
        *)
            return 1
            ;;
    esac
}


# =============================================================================
# UI AND COMMAND HANDLING
# =============================================================================

# Function to show version information
show_version() {
    echo -e "${PURPLE}$TOOL_NAME v$TOOL_VERSION${NC}"
    echo -e "${CYAN}Developer: $DEVELOPER${NC}"
    echo -e "${CYAN}Instagram: @$DEVELOPER_IG${NC}"
    echo -e "${CYAN}GitHub: $GITHUB_URL${NC}"
    echo ""
    echo -e "${BLUE}Advanced Network Discovery & Reconnaissance Tool${NC}"
    echo -e "${GREEN}Features: Stealth scanning, intelligent filtering, auto-updates${NC}"
}

# Show system installation status
show_system_status() {
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë             System Status             ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""

    # Check current installation type
    if is_system_wide_install; then
        echo -e "${GREEN}üìç Installation Type: System-wide${NC}"
        echo -e "${CYAN}üìÇ Script Location: $SCRIPT_PATH${NC}"
        echo -e "${CYAN}üìÇ Config Location: $SYSTEM_CONFIG_DIR${NC}"
    else
        echo -e "${YELLOW}üìç Installation Type: Local${NC}"
        echo -e "${CYAN}üìÇ Script Location: $SCRIPT_PATH${NC}"
        echo -e "${CYAN}üìÇ Config Location: $(dirname "$SCRIPT_PATH")${NC}"
    fi

    echo ""

    # Check if system-wide command exists
    if command -v huntr &> /dev/null; then
        echo -e "${GREEN}‚úÖ System-wide command available${NC}"
        echo -e "${CYAN}   Location: $(which huntr)${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  System-wide command not available${NC}"
    fi

    # Check v6module
    local v6_locations=("$SYSTEM_CONFIG_DIR/.v6module" "$(dirname "$SCRIPT_PATH")/.v6module")
    local v6_found=false

    for location in "${v6_locations[@]}"; do
        if [[ -f "$location" ]]; then
            echo -e "${GREEN}‚úÖ v6module found: $location${NC}"
            v6_found=true
            break
        fi
    done

    if [ "$v6_found" = false ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  v6module not found${NC}"
    fi

    echo ""
    echo -e "${BLUE}Available Actions:${NC}"
    echo -e "${CYAN}‚Ä¢ $SCRIPT_NAME --install-system  (Install system-wide)${NC}"
    echo -e "${CYAN}‚Ä¢ $SCRIPT_NAME --uninstall-system (Remove system-wide)${NC}"
    echo -e "${CYAN}‚Ä¢ $SCRIPT_NAME --update           (Update current installation)${NC}"
}

# Enhanced help with new options
show_help_enhanced() {
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë              $TOOL_NAME v$TOOL_VERSION Help              ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo "Usage: $SCRIPT_NAME [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help            Show this help message"
    echo "  -v, --version         Show version information"
    echo "  -u, --update          Check for updates and update if available"
    echo "  --check-update        Check for updates without prompting to install"
    echo "  --install-system      Install system-wide (requires sudo)"
    echo "  --uninstall-system    Remove system-wide installation (requires sudo)"
    echo "  --system-status       Show installation status and configuration"
    echo ""
    echo "Interactive Mode:"
    echo "  Run without arguments to enter interactive mode with menu options"
    echo ""
    echo "Examples:"
    echo "  $SCRIPT_NAME                    # Run in interactive mode"
    echo "  $SCRIPT_NAME --update           # Force update check"
    echo "  $SCRIPT_NAME --install-system   # Install system-wide"
    echo "  $SCRIPT_NAME --system-status    # Show system status"
    echo ""
    echo "System-wide Installation:"
    echo "  After installing system-wide, you can run 'huntr' from anywhere"
    echo "  Updates will be applied to the system-wide installation"
    echo ""
}

# Enhanced menu with improved nmap options
show_enhanced_menu() {
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë   ü•∑ $TOOL_NAME - Network Stealth Sweeper   ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë      Nmap Integration & Filtering          ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë              v$TOOL_VERSION                  ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë       Developed by $DEVELOPER            ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë   IG: @$DEVELOPER_IG | $GITHUB_URL   ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo -e "${CYAN}Features: Intelligent filtering, XML parsing, advanced discovery${NC}"
    echo ""
    echo "Host Discovery Methods:"
    echo "1. ü•∑ Ultra-stealth nmap (decoys + advanced evasion)"
    echo "2. ‚ö° Fast optimized nmap (intelligent discovery)"
    echo "3. üîç Stealth + Port discovery (comprehensive)"
    echo "4. üîç Fast + Port discovery (quick comprehensive)"

    # Show v6module options if available
    if $V6_MODULE_AVAILABLE; then
        echo ""
        echo -e "${CYAN}Enhanced Features (v6module):${NC}"
        echo "5. üåê IPv6 + IPv4 dual-stack scan"
        echo "6. üì° UDP + TCP comprehensive scan"
        echo "7. üñ•Ô∏è  OS fingerprinting + services"
        echo "8. üö® Full vulnerability assessment"
        echo "9. üì∂ ARP + topology mapping"
        echo "10. üîß Configure v6module settings"
        echo "11. üåê HTTP service enumeration (port 80)"
        echo "12. üîç HTTP full port sweep + enumeration"
        echo "13. üî¨ Web application fingerprinting"
        echo "14. üè¢ SMB/NetBIOS enumeration"
        echo "15. üóÑÔ∏è  Database service discovery"
        echo "16. üì± IoT & embedded device discovery"
        echo "17. üöÄ Ultimate recon (all techniques)"
    fi

    echo ""
    echo -e "${YELLOW}Nmap Configuration:${NC}"
    echo "‚Ä¢ Parallel hosts: $NMAP_PARALLEL_MIN-$NMAP_PARALLEL_MAX"
    echo "‚Ä¢ Host timeout: $NMAP_HOST_TIMEOUT"
    echo "‚Ä¢ Discovery probes: Multiple ICMP + TCP ACK"
    echo "‚Ä¢ XML parsing: $(command -v xmllint &> /dev/null && echo "Enhanced" || echo "Basic")"
    echo ""

    if $V6_MODULE_AVAILABLE; then
        read -p "Select method (1-17): " method
    else
        read -p "Select method (1-4): " method
    fi
}

# Enhanced argument handling with new options
handle_arguments_enhanced() {
    case "$1" in
        -h|--help)
            show_help_enhanced
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        -u|--update)
            echo -e "${BLUE}üîÑ Forcing update check...${NC}"
            check_for_updates_enhanced
            local update_status=$?
            if [ $update_status -eq 0 ]; then
                perform_update_enhanced "${@:2}"
            elif [ $update_status -eq 2 ]; then
                echo -e "${GREEN}‚úÖ No update needed. Running latest version.${NC}"
            else
                echo -e "${RED}‚ùå Update check failed.${NC}"
            fi
            exit 0
            ;;
        --check-update)
            check_for_updates_enhanced
            exit 0
            ;;
        --install-system)
            install_system_wide
            exit $?
            ;;
        --uninstall-system)
            uninstall_system_wide
            exit $?
            ;;
        --system-status)
            show_system_status
            exit 0
            ;;
        "")
            # No arguments - continue to interactive mode
            return 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================
main() {
    # Handle command line arguments first. If an argument is handled, the script will exit.
    handle_arguments_enhanced "$@"

    clear
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë                 ü•∑ $TOOL_NAME                  ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë Advanced Network scanner with target Filtering  ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë                   v$TOOL_VERSION                  ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë         Developed by $DEVELOPER               ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë      IG: @$DEVELOPER_IG | GitHub: $GITHUB_REPO ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""

    # Show system status if first time running system-wide
    if is_system_wide_install && [[ ! -f "$USER_CONFIG_DIR/.huntr_intro_shown" ]]; then
        echo -e "${GREEN}üéâ Welcome to the system-wide Huntr installation!${NC}"
        show_system_status
        mkdir -p "$USER_CONFIG_DIR"
        touch "$USER_CONFIG_DIR/.huntr_intro_shown"
        echo ""
    fi

    # Perform automatic update check (silent) on interactive startup
    check_for_updates_enhanced "silent"
    local update_status=$?
    if [ $update_status -eq 0 ]; then
        echo -e "${GREEN}üÜï A new version is available! Use '$SCRIPT_NAME --update' to upgrade.${NC}"
        echo ""
    fi

    # Check and install dependencies
    check_and_install_deps

    # Verify nmap is available
    if ! $HAVE_NMAP; then
        echo -e "${RED}ERROR: nmap is required but not available${NC}"
        echo -e "${YELLOW}Please install nmap manually and run the script again${NC}"
        exit 1
    fi
    # Get network base from user
    read -p "Enter network base (LIKE THIS. 7 DIGITS EXACT!, 192.168.0): " network_base

    # Validate network base format
    if ! [[ $network_base =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        echo -e "${RED}Invalid network format. Please use format like: 192.168.1${NC}"
        exit 1
    fi

    # Show enhanced menu and handle selection
    show_enhanced_menu

    case $method in
        1)
            ultra_stealth_nmap "$network_base"
            ;;
        2)
            fast_nmap_discovery "$network_base"
            ;;
        3)
            ultra_stealth_nmap "$network_base"
            echo ""
            nmap_port_discovery "$network_base" "stealth"
            ;;
        4)
            fast_nmap_discovery "$network_base"
            echo ""
            nmap_port_discovery "$network_base" "fast"
            ;;
        5)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "stealth" "ipv6,arp,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        6)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "fast" "udp,tcp,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        7)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "fast" "os,service,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        8)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "stealth" "vuln,service,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        9)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "fast" "arp,topology,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        10)
            if $V6_MODULE_AVAILABLE; then
                show_v6_menu
                # Handle v6 menu selection here
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        11)
            if $V6_MODULE_AVAILABLE; then
                http_service_enum "$network_base" "fast" "80"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        12)
            if $V6_MODULE_AVAILABLE; then
                echo -e "${YELLOW}‚ö†Ô∏è  Full port sweep may take 10-30 minutes${NC}"
                read -p "Continue? (y/N): " confirm
                if [[ $confirm =~ ^[Yy]$ ]]; then
                    # First find active hosts
                    fast_nmap_discovery "$network_base"
                    echo ""
                    # Then do HTTP enumeration with full port range
                    http_service_enum "$network_base" "fast" "-"
                fi
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        13)
            if $V6_MODULE_AVAILABLE; then
                web_app_fingerprinting "$network_base" "fast"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        14)
            if $V6_MODULE_AVAILABLE; then
                smb_enumeration "$network_base" "fast"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        15)
            if $V6_MODULE_AVAILABLE; then
                database_enum "$network_base" "fast"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        16)
            if $V6_MODULE_AVAILABLE; then
                iot_device_discovery "$network_base" "fast"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        17)
            if $V6_MODULE_AVAILABLE; then
                echo -e "${RED}üöÄ ULTIMATE RECON MODE${NC}"
                echo -e "${YELLOW}‚ö†Ô∏è  This will perform comprehensive scanning and may take 30+ minutes${NC}"
                read -p "Continue with ultimate recon? (y/N): " confirm
                if [[ $confirm =~ ^[Yy]$ ]]; then
                    echo -e "${PURPLE}üî• Initiating ultimate reconnaissance...${NC}"
                    echo ""

                    # Stage 1: Host Discovery
                    echo -e "${CYAN}Stage 1: Host Discovery${NC}"
                    fast_nmap_discovery "$network_base"
                    echo ""

                    # Stage 2: Service Enumeration
                    echo -e "${CYAN}Stage 2: Service Enumeration${NC}"
                    http_service_enum "$network_base" "fast" "80,443,8080,8443"
                    echo ""

                    # Stage 3: Web Application Fingerprinting
                    echo -e "${CYAN}Stage 3: Web Application Analysis${NC}"
                    web_app_fingerprinting "$network_base" "fast"
                    echo ""

                    # Stage 4: SMB Enumeration
                    echo -e "${CYAN}Stage 4: SMB/Windows Enumeration${NC}"
                    smb_enumeration "$network_base" "fast"
                    echo ""

                    # Stage 5: Database Discovery
                    echo -e "${CYAN}Stage 5: Database Service Discovery${NC}"
                    database_enum "$network_base" "fast"
                    echo ""

                    # Stage 6: IoT Discovery
                    echo -e "${CYAN}Stage 6: IoT Device Discovery${NC}"
                    iot_device_discovery "$network_base" "fast"
                    echo ""

                    # Stage 7: Vulnerability Assessment
                    echo -e "${CYAN}Stage 7: Vulnerability Assessment${NC}"
                    enhanced_network_scan "$network_base" "fast" "vuln,service,report"
                    echo ""

                    echo -e "${GREEN}üéâ Ultimate recon completed!${NC}"
                    echo -e "${CYAN}Check $OUTPUT_DIR for detailed reports${NC}"
                fi
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        *)
            echo -e "${RED}Invalid option selected${NC}"
            exit 1
            ;;
    esac

    echo ""
    echo -e "${CYAN}üí° Pro Tips:${NC}"
    echo -e "${GREEN}‚Ä¢ Use method 17 for comprehensive penetration testing${NC}"
    echo -e "${GREEN}‚Ä¢ Methods 11-16 are specialized for specific services${NC}"
    echo -e "${GREEN}‚Ä¢ Use method 2 for network admin tasks${NC}"
    echo -e "${GREEN}‚Ä¢ Use method 1 for penetration testing${NC}"
    echo -e "${GREEN}‚Ä¢ Run '$SCRIPT_NAME --update' to check for updates${NC}"
    echo -e "${GREEN}‚Ä¢ Visit $GITHUB_URL for documentation${NC}"
    echo ""
    echo -e "${PURPLE}Thank you for using $TOOL_NAME v$TOOL_VERSION by $DEVELOPER${NC}"
}

# Execute main function with all script arguments
main "$@"
