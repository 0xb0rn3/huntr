#!/usr/bin/env bash

# Tool Information
TOOL_NAME="Huntr"
TOOL_VERSION="0.1.2"
DEVELOPER="0xb0rn3 | 0xbv1"
DEVELOPER_IG="theehiv3"
GITHUB_REPO="0xb0rn3/huntr"
GITHUB_URL="https://github.com/${GITHUB_REPO}"

# Color codes for better user experience
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variables to track what we have available
HAVE_NMAP=false
HAVE_FPING=false
HAVE_MASSCAN=false
HAVE_HPING3=false

# Load v6module if available
V6_MODULE_AVAILABLE=false
if [[ -f "./.v6module" ]]; then
    source "./.v6module"
    V6_MODULE_AVAILABLE=true
    echo -e "${GREEN}‚úÖ v6module loaded${NC}"
else
    echo -e "${YELLOW}‚ö†Ô∏è  v6module not found. Advanced features disabled.${NC}"
fi
# Enhanced stealth configuration variables
STEALTH_MODE=false
RANDOMIZE_ORDER=true
DECOY_COUNT=3
MIN_DELAY=0.1
MAX_DELAY=0.5

# Nmap optimization variables
NMAP_PARALLEL_MIN=10
NMAP_PARALLEL_MAX=50
NMAP_HOST_TIMEOUT="3s"
NMAP_DISCOVERY_PROBES=4

# Update check configuration
UPDATE_CHECK_URL="https://api.github.com/repos/${GITHUB_REPO}/releases/latest"
SCRIPT_NAME="$(basename "$0")"
SCRIPT_PATH="$(realpath "$0")"

# Function to compare version numbers (semantic versioning)
version_compare() {
    local version1="$1"
    local version2="$2"
    
    # Remove 'v' prefix if present
    version1=$(echo "$version1" | sed 's/^v//')
    version2=$(echo "$version2" | sed 's/^v//')
    
    # Split versions into arrays
    IFS='.' read -ra v1_parts <<< "$version1"
    IFS='.' read -ra v2_parts <<< "$version2"
    
    # Pad arrays to same length
    local max_length=${#v1_parts[@]}
    if [ ${#v2_parts[@]} -gt $max_length ]; then
        max_length=${#v2_parts[@]}
    fi
    
    # Compare each part
    for ((i=0; i<max_length; i++)); do
        local part1=${v1_parts[i]:-0}
        local part2=${v2_parts[i]:-0}
        
        if [ "$part1" -lt "$part2" ]; then
            echo "less"
            return
        elif [ "$part1" -gt "$part2" ]; then
            echo "greater"
            return
        fi
    done
    
    echo "equal"
}

# Function to check for updates
check_for_updates() {
    local silent_mode="$1"  # If "silent", don't show checking message
    
    if [ "$silent_mode" != "silent" ]; then
        echo -e "${BLUE}üîÑ Checking for updates...${NC}"
    fi
    
    # Check if we have internet connectivity
    if ! ping -c 1 -W 2 8.8.8.8 &> /dev/null && ! ping -c 1 -W 2 1.1.1.1 &> /dev/null; then
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  No internet connection. Cannot check for updates.${NC}"
        fi
        return 1
    fi
    
    # Check if curl is available
    if ! command -v curl &> /dev/null; then
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  curl not found. Cannot check for updates.${NC}"
        fi
        return 1
    fi
    
    # Fetch latest release information from GitHub API
    local api_response
    api_response=$(curl -s --connect-timeout 10 --max-time 30 "$UPDATE_CHECK_URL" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$api_response" ]; then
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Failed to fetch update information from GitHub.${NC}"
        fi
        return 1
    fi
    
    # Parse the latest version from JSON response
    local latest_version
    if command -v jq &> /dev/null; then
        # Use jq for precise JSON parsing if available
        latest_version=$(echo "$api_response" | jq -r '.tag_name' 2>/dev/null)
    else
        # Fallback to grep/sed parsing
        latest_version=$(echo "$api_response" | grep -o '"tag_name":"[^"]*"' | cut -d'"' -f4)
    fi
    
    if [ -z "$latest_version" ] || [ "$latest_version" = "null" ]; then
        if [ "$silent_mode" != "silent" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Unable to parse version information.${NC}"
        fi
        return 1
    fi
    
    # Compare versions
    local comparison=$(version_compare "$TOOL_VERSION" "$latest_version")
    
    case $comparison in
        "less")
            echo -e "${GREEN}üÜï New version available: $latest_version (current: $TOOL_VERSION)${NC}"
            return 0  # Update available
            ;;
        "equal")
            if [ "$silent_mode" != "silent" ]; then
                echo -e "${GREEN}‚úÖ Running latest version ($TOOL_VERSION)${NC}"
            fi
            return 2  # Already latest
            ;;
        "greater")
            if [ "$silent_mode" != "silent" ]; then
                echo -e "${CYAN}üß™ Running development version ($TOOL_VERSION > $latest_version)${NC}"
            fi
            return 2  # Development version
            ;;
    esac
    
    return 1  # Error case
}

# Function to perform automatic update
perform_update() {
    echo -e "${BLUE}üîÑ Starting automatic update process...${NC}"
    
    # Create temporary directory for download
    local temp_dir=$(mktemp -d)
    local temp_script="$temp_dir/$(basename "$SCRIPT_PATH")"
    
    echo -e "${CYAN}üì• Downloading latest version...${NC}"
    
    # Download the latest version
    local download_url="https://raw.githubusercontent.com/${GITHUB_REPO}/main/$(basename "$SCRIPT_PATH")"
    
    if curl -s --connect-timeout 10 --max-time 60 -o "$temp_script" "$download_url"; then
        # Verify the download
        if [ -s "$temp_script" ] && head -1 "$temp_script" | grep -q "#!/usr/bin/env bash"; then
            echo -e "${GREEN}‚úÖ Download successful${NC}"
            
            # Make the new script executable
            chmod +x "$temp_script"
            
            # Create backup of current version
            local backup_path="${SCRIPT_PATH}.backup.$(date +%Y%m%d_%H%M%S)"
            cp "$SCRIPT_PATH" "$backup_path"
            echo -e "${CYAN}üíæ Backup created: $backup_path${NC}"
            
            # Replace current script with new version
            if cp "$temp_script" "$SCRIPT_PATH"; then
                echo -e "${GREEN}üéâ Update completed successfully!${NC}"
                echo -e "${CYAN}üîÑ Restarting with new version...${NC}"
                echo ""
                
                # Cleanup
                rm -rf "$temp_dir"
                
                # Restart the script with the same arguments
                exec "$SCRIPT_PATH" "$@"
            else
                echo -e "${RED}‚ùå Failed to replace script. Restoring backup...${NC}"
                cp "$backup_path" "$SCRIPT_PATH"
                rm -rf "$temp_dir"
                return 1
            fi
        else
            echo -e "${RED}‚ùå Downloaded file appears to be invalid${NC}"
            rm -rf "$temp_dir"
            return 1
        fi
    else
        echo -e "${RED}‚ùå Download failed${NC}"
        rm -rf "$temp_dir"
        return 1
    fi
}

# Function to handle update process with user interaction
handle_update_check() {
    check_for_updates
    local update_status=$?
    
    case $update_status in
        0)  # Update available
            echo ""
            read -p "Would you like to update now? (y/N): " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                perform_update "$@"
            else
                echo -e "${YELLOW}‚è≠Ô∏è  Update skipped. You can update later by running: $SCRIPT_NAME --update${NC}"
            fi
            ;;
        2)  # Already latest version
            # Already handled in check_for_updates
            ;;
        *)  # Error or no connection
            # Already handled in check_for_updates
            ;;
    esac
    echo ""
}

# Function to generate random MAC address for spoofing
generate_random_mac() {
    printf '02:%02x:%02x:%02x:%02x:%02x\n' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# Function to get random delay between probes
get_random_delay() {
    local min_delay=$1
    local max_delay=$2
    # Generate random delay between min and max (in seconds)
    echo "scale=2; $min_delay + ($max_delay - $min_delay) * $RANDOM / 32767" | bc -l 2>/dev/null || echo "$min_delay"
}

# Enhanced function to create intelligent decoy IP list
generate_smart_decoys() {
    local network_base="$1"
    local target_range_start="$2"
    local target_range_end="$3"
    local decoy_list=""
    
    # Create decoys that blend with the network topology
    for i in $(seq 1 $DECOY_COUNT); do
        local random_host
        
        # 70% chance to use nearby IPs (more realistic)
        if (( RANDOM % 10 < 7 )); then
            # Generate IP close to target range but outside it
            local range_size=$((target_range_end - target_range_start))
            local offset=$((RANDOM % (range_size * 2) + 1))
            
            if (( target_range_start - offset > 1 )); then
                random_host=$((target_range_start - offset))
            elif (( target_range_end + offset < 254 )); then
                random_host=$((target_range_end + offset))
            else
                random_host=$((RANDOM % 254 + 1))
            fi
        else
            # 30% chance for completely random (noise)
            random_host=$((RANDOM % 254 + 1))
        fi
        
        # Avoid common gateway/broadcast/multicast ranges
        while [[ $random_host -eq 1 || $random_host -eq 254 || $random_host -eq 255 || 
                 ($random_host -ge 224 && $random_host -le 239) ]]; do
            random_host=$((RANDOM % 254 + 1))
        done
        
        if [ -n "$decoy_list" ]; then
            decoy_list="${decoy_list},${network_base}.${random_host}"
        else
            decoy_list="${network_base}.${random_host}"
        fi
    done
    
    echo "$decoy_list"
}

# Advanced nmap host discovery with intelligent filtering
optimized_nmap_discovery() {
    local network_base="$1"
    local scan_type="$2"  # "stealth" or "fast"
    
    echo -e "${BLUE}üéØ Using advanced nmap host discovery with intelligent filtering...${NC}"
    
    local nmap_args=""
    local timing_template=""
    local discovery_method=""
    
    # Configure nmap based on scan type
    if [[ "$scan_type" == "stealth" ]]; then
        echo -e "${PURPLE}ü•∑ STEALTH MODE: Advanced evasion techniques enabled${NC}"
        
        # Generate smart decoys for the entire range
        local decoys=$(generate_smart_decoys "$network_base" 1 254)
        echo -e "${CYAN}Using intelligent decoy IPs: $decoys${NC}"
        
        timing_template="T1"
        discovery_method="-PE -PP -PM -PO"  # Multiple ICMP types for better coverage
        
        nmap_args="--randomize-hosts \
                      --data-length $((RANDOM % 32 + 16)) \
                      --ttl $((32 + RANDOM % 32)) \
                      -D $decoys \
                      --scan-delay $(get_random_delay 0.5 2.0) \
                      --max-parallelism $NMAP_PARALLEL_MIN \
                      --min-parallelism 5 \
                      -f \
                      --spoof-mac $(generate_random_mac) \
                      --host-timeout $NMAP_HOST_TIMEOUT"
    else
        echo -e "${GREEN}‚ö° FAST MODE: Optimized for speed and efficiency${NC}"
        
        timing_template="T4"
        discovery_method="-PE -PA80,443,22,21,25,53,135,139,445"  # TCP ACK to common ports
        
        nmap_args="--min-parallelism $NMAP_PARALLEL_MIN \
                      --max-parallelism $NMAP_PARALLEL_MAX \
                      --host-timeout $NMAP_HOST_TIMEOUT \
                      --max-retries 2"
    fi
    
    start_time=$(date +%s)
    
    # Execute nmap with intelligent output parsing
    echo -e "${CYAN}Discovery method: $discovery_method${NC}"
    echo -e "${CYAN}Timing template: $timing_template${NC}"
    echo ""
    
    # Use nmap's XML output for better parsing reliability
    local temp_xml=$(mktemp)
    local temp_results=$(mktemp)
    
    # Execute the nmap scan with comprehensive host discovery
    nmap -sn \
         -$timing_template \
         $discovery_method \
         $nmap_args \
         -oX "$temp_xml" \
         "${network_base}.1-254" 2>/dev/null
    
    # Parse XML output for more reliable results
    if command -v xmllint &> /dev/null; then
        # Use xmllint for precise XML parsing
        xmllint --xpath "//host[status/@state='up']/address[@addrtype='ipv4']/@addr" "$temp_xml" 2>/dev/null | \
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | \
        sort -V > "$temp_results"
    else
        # Fallback to grep/awk parsing with improved accuracy
        grep -E "<address addr=\"[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\" addrtype=\"ipv4\"/>" "$temp_xml" | \
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | \
        sort -V > "$temp_results"
    fi
    
    # Enhanced result processing with host information
    local host_count=0
    echo -e "${GREEN}üìã Active hosts discovered:${NC}"
    echo "----------------------------------------"
    
    while IFS= read -r ip_addr; do
        ((host_count++))
        
        # Get hostname if available from nmap results
        local hostname=""
        if grep -q "hostname.*name=\".*\".*type=\"PTR\"" "$temp_xml"; then
            hostname=$(grep -A5 -B5 "$ip_addr" "$temp_xml" | \
                         grep -oE "hostname.*name=\"[^\"]*\"" | \
                         head -1 | \
                         sed 's/.*name="\([^"]*\)".*/\1/')
        fi
        
        # Display results with enhanced formatting
        if [[ -n "$hostname" && "$hostname" != "$ip_addr" ]]; then
            echo -e "${GREEN}üéØ $ip_addr${NC} ${CYAN}($hostname)${NC}"
        else
            echo -e "${GREEN}üéØ $ip_addr${NC}"
        fi
        
        # Add small delay in stealth mode to avoid burst patterns
        if [[ "$scan_type" == "stealth" ]]; then
            sleep $(get_random_delay 0.1 0.3)
        fi
        
    done < "$temp_results"
    
    # Cleanup temporary files
    rm -f "$temp_xml" "$temp_results"
    
    end_time=$(date +%s)
    scan_duration=$((end_time - start_time))
    
    echo "----------------------------------------"
    echo -e "${BLUE}üìä Scan Summary:${NC}"
    echo -e "${GREEN}‚Ä¢ Active hosts found: $host_count${NC}"
    echo -e "${GREEN}‚Ä¢ Scan duration: ${scan_duration}s${NC}"
    echo -e "${GREEN}‚Ä¢ Average time per host: $(echo "scale=2; $scan_duration / 254" | bc -l)s${NC}"
    
    if [[ "$scan_type" == "stealth" ]]; then
        echo -e "${PURPLE}‚Ä¢ Stealth techniques: Decoys, timing randomization, packet fragmentation${NC}"
    else
        echo -e "${CYAN}‚Ä¢ Optimization: Parallel processing, smart timeouts, multi-probe discovery${NC}"
    fi
}

# Ultra-stealth nmap with advanced evasion - IMPROVED VERSION
ultra_stealth_nmap() {
    local network_base="$1"
    optimized_nmap_discovery "$network_base" "stealth"
}

# Fast optimized nmap - IMPROVED VERSION
fast_nmap_discovery() {
    local network_base="$1"
    optimized_nmap_discovery "$network_base" "fast"
}

# Advanced nmap port discovery for found hosts
nmap_port_discovery() {
    local network_base="$1"
    local scan_type="$2"
    
    echo -e "${BLUE}üîç Performing port discovery on active hosts...${NC}"
    
    # First, get list of active hosts
    local temp_hosts=$(mktemp)
    local temp_xml=$(mktemp)
    
    # Quick host discovery first
    nmap -sn -T4 "${network_base}.1-254" -oX "$temp_xml" 2>/dev/null
    
    if command -v xmllint &> /dev/null; then
        xmllint --xpath "//host[status/@state='up']/address[@addrtype='ipv4']/@addr" "$temp_xml" 2>/dev/null | \
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" > "$temp_hosts"
    else
        grep -oE "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" "$temp_xml" > "$temp_hosts"
    fi
    
    local host_count=$(wc -l < "$temp_hosts")
    
    if [[ $host_count -eq 0 ]]; then
        echo -e "${YELLOW}No active hosts found for port scanning${NC}"
        rm -f "$temp_hosts" "$temp_xml"
        return
    fi
    
    echo -e "${GREEN}Found $host_count active hosts. Starting port discovery...${NC}"
    echo ""
    
    # Configure port scan based on type
    local port_args=""
    local ports="22,23,25,53,80,110,135,139,443,445,993,995,1723,3389,5900"
    
    if [[ "$scan_type" == "stealth" ]]; then
        echo -e "${PURPLE}ü•∑ Stealth port discovery with SYN stealth scan${NC}"
        port_args="-sS -T2 --randomize-hosts -f"
    else
        echo -e "${GREEN}‚ö° Fast port discovery with connect scan${NC}"
        port_args="-sT -T4 --min-parallelism 20 --max-parallelism 100"
    fi
    
    # Scan each host for common ports
    while IFS= read -r host; do
        echo -e "${CYAN}Scanning $host for common services...${NC}"
        
        local port_results=$(mktemp)
        nmap $port_args -p "$ports" --open "$host" -oG "$port_results" 2>/dev/null
        
        # Parse and display open ports
        local open_ports=$(grep "Ports:" "$port_results" | \
                             grep -oE "[0-9]+/open" | \
                             cut -d'/' -f1 | \
                             tr '\n' ',' | \
                             sed 's/,$//')
        
        if [[ -n "$open_ports" ]]; then
            echo -e "${GREEN}  ‚îî‚îÄ Open ports: $open_ports${NC}"
        else
            echo -e "${YELLOW}  ‚îî‚îÄ No common ports open${NC}"
        fi
        
        rm -f "$port_results"
        
        # Small delay between hosts in stealth mode
        if [[ "$scan_type" == "stealth" ]]; then
            sleep $(get_random_delay 1.0 2.0)
        fi
        
    done < "$temp_hosts"
    
    rm -f "$temp_hosts" "$temp_xml"
}

# Function to detect dependencies including stealth tools
check_and_install_deps() {
    local pkg_manager
    local network_ok=true
    
    echo -e "${BLUE}=== Dependency Check & Auto-Installation ===${NC}"
    
    # Quick network check first
    echo -ne "${BLUE}Checking network connectivity...${NC}"
    if ping -c 1 -W 2 8.8.8.8 &> /dev/null || ping -c 1 -W 2 1.1.1.1 &> /dev/null; then
        echo -e " ${GREEN}‚úì Online${NC}"
        network_ok=true
    else
        echo -e " ${RED}‚úó Offline${NC}"
        echo -e "${YELLOW}Warning: No internet connection detected. Cannot install missing tools.${NC}"
        network_ok=false
    fi
    if $V6_MODULE_AVAILABLE; then
        init_v6_module
    fi
    # Detect package manager
    pkg_manager=$(detect_package_manager)
    if [ "$pkg_manager" = "unknown" ]; then
        echo -e "${YELLOW}Warning: Unknown package manager. Manual installation may be required.${NC}"
    fi
    
    # Check core tools with improved detection
    local tools=("nmap:nmap" "fping:fping" "masscan:masscan" "hping3:hping3" "bc:bc" "shuf:coreutils" "xmllint:libxml2-utils")
    
    for tool_info in "${tools[@]}"; do
        IFS=':' read -r tool package <<< "$tool_info"
        echo -ne "${BLUE}Checking $tool...${NC}"
        
        if command -v "$tool" &> /dev/null; then
            echo -e " ${GREEN}‚úì Found${NC}"
            case $tool in
                "nmap") HAVE_NMAP=true ;;
                "fping") HAVE_FPING=true ;;
                "masscan") HAVE_MASSCAN=true ;;
                "hping3") HAVE_HPING3=true ;;
            esac
        else
            echo -ne " ${YELLOW}Missing${NC}"
            if $network_ok && [ "$pkg_manager" != "unknown" ]; then
                echo -ne " - Installing..."
                if install_package "$package" "$pkg_manager"; then
                    echo -e " ${GREEN}‚úì Installed${NC}"
                    case $tool in
                        "nmap") HAVE_NMAP=true ;;
                        "fping") HAVE_FPING=true ;;
                        "masscan") HAVE_MASSCAN=true ;;
                        "hping3") HAVE_HPING3=true ;;
                    esac
                else
                    echo -e " ${RED}‚úó Failed${NC}"
                fi
            else
                echo -e " ${RED}‚úó Cannot install${NC}"
            fi
        fi
    done
    
    echo ""
}

# Function to detect the package manager and OS
detect_package_manager() {
    if command -v apt-get &> /dev/null; then
        echo "apt"
    elif command -v yum &> /dev/null; then
        echo "yum"
    elif command -v dnf &> /dev/null; then
        echo "dnf"
    elif command -v pacman &> /dev/null; then
        echo "pacman"
    elif command -v zypper &> /dev/null; then
        echo "zypper"
    elif command -v apk &> /dev/null; then
        echo "apk"
    else
        echo "unknown"
    fi
}

# Function to install a package based on the detected package manager
install_package() {
    local package_name="$1"
    local pkg_manager="$2"
    
    case $pkg_manager in
        "apt")
            sudo apt-get update &> /dev/null && sudo apt-get install -y "$package_name" &> /dev/null
            ;;
        "yum")
            sudo yum install -y "$package_name" &> /dev/null
            ;;
        "dnf")
            sudo dnf install -y "$package_name" &> /dev/null
            ;;
        "pacman")
            sudo pacman -Sy --noconfirm "$package_name" &> /dev/null
            ;;
        "zypper")
            sudo zypper install -y "$package_name" &> /dev/null
            ;;
        "apk")
            sudo apk add "$package_name" &> /dev/null
            ;;
        *)
            return 1
            ;;
    esac
}

# Function to show help information
show_help() {
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë              $TOOL_NAME v$TOOL_VERSION Help               ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo "Usage: $SCRIPT_NAME [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help      Show this help message"
    echo "  -v, --version   Show version information"
    echo "  -u, --update    Check for updates and update if available"
    echo "  --check-update  Check for updates without prompting to install"
    echo ""
    echo "Interactive Mode:"
    echo "  Run without arguments to enter interactive mode with menu options"
    echo ""
    echo "Examples:"
    echo "  $SCRIPT_NAME                  # Run in interactive mode"
    echo "  $SCRIPT_NAME --update         # Force update check"
    echo "  $SCRIPT_NAME --version        # Show version info"
    echo ""
}

# Function to show version information
show_version() {
    echo -e "${PURPLE}$TOOL_NAME v$TOOL_VERSION${NC}"
    echo -e "${CYAN}Developer: $DEVELOPER${NC}"
    echo -e "${CYAN}Instagram: @$DEVELOPER_IG${NC}"
    echo -e "${CYAN}GitHub: $GITHUB_URL${NC}"
    echo ""
    echo -e "${BLUE}Advanced Network Discovery & Reconnaissance Tool${NC}"
    echo -e "${GREEN}Features: Stealth scanning, intelligent filtering, auto-updates${NC}"
}

# Enhanced menu with improved nmap options
show_enhanced_menu() {
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë   ü•∑ $TOOL_NAME - Network Stealth Sweeper ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë       Nmap Integration & Filtering       ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë              v$TOOL_VERSION              ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë        Developed by $DEVELOPER         ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë    IG: @$DEVELOPER_IG | $GITHUB_URL    ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo -e "${CYAN}Features: Intelligent filtering, XML parsing, advanced discovery${NC}"
    echo ""
    echo "Host Discovery Methods:"
    echo "1. ü•∑ Ultra-stealth nmap (decoys + advanced evasion)"
    echo "2. ‚ö° Fast optimized nmap (intelligent discovery)"
    echo "3. üîç Stealth + Port discovery (comprehensive)"
    echo "4. üîç Fast + Port discovery (quick comprehensive)"
    
    # Show v6module options if available
    if $V6_MODULE_AVAILABLE; then
        echo ""
        echo -e "${CYAN}Enhanced Features (v6module):${NC}"
        echo "5. üåê IPv6 + IPv4 dual-stack scan"
        echo "6. üì° UDP + TCP comprehensive scan"
        echo "7. üñ•Ô∏è  OS fingerprinting + services"
        echo "8. üö® Full vulnerability assessment"
        echo "9. üì∂ ARP + topology mapping"
        echo "10. üîß Configure v6module settings"
    fi
    
    echo ""
    echo -e "${YELLOW}Nmap Configuration:${NC}"
    echo "‚Ä¢ Parallel hosts: $NMAP_PARALLEL_MIN-$NMAP_PARALLEL_MAX"
    echo "‚Ä¢ Host timeout: $NMAP_HOST_TIMEOUT"
    echo "‚Ä¢ Discovery probes: Multiple ICMP + TCP ACK"
    echo "‚Ä¢ XML parsing: $(command -v xmllint &> /dev/null && echo "Enhanced" || echo "Basic")"
    echo ""
    
    if $V6_MODULE_AVAILABLE; then
        read -p "Select method (1-10): " method
    else
        read -p "Select method (1-4): " method
    fi
}

# Command line argument handling
handle_arguments() {
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        -u|--update)
            echo -e "${BLUE}üîÑ Forcing update check...${NC}"
            check_for_updates
            local update_status=$?
            if [ $update_status -eq 0 ]; then
                perform_update "${@:2}"
            elif [ $update_status -eq 2 ]; then
                echo -e "${GREEN}‚úÖ No update needed. Running latest version.${NC}"
            else
                echo -e "${RED}‚ùå Update check failed.${NC}"
            fi
            exit 0
            ;;
        --check-update)
            check_for_updates
            exit 0
            ;;
        "")
            # No arguments - continue to interactive mode
            return 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
}

# Main execution starts here
main() {
    # Handle command line arguments first
    handle_arguments "$@"
    
    clear
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë   ü•∑ $TOOL_NAME - Network Stealth Sweeper   ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë   Advanced Nmap Integration & Filtering  ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë               v$TOOL_VERSION               ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë        Developed by $DEVELOPER         ‚ïë${NC}"
    echo -e "${PURPLE}‚ïë       IG: @$DEVELOPER_IG | GitHub: $GITHUB_REPO ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""

    # Perform automatic update check (silent)
    check_for_updates "silent"
    local update_status=$?
    if [ $update_status -eq 0 ]; then
        echo -e "${GREEN}üÜï A new version is available! Use --update to upgrade.${NC}"
        echo ""
    fi

    # Check and install dependencies
    check_and_install_deps

    # Verify nmap is available
    if ! $HAVE_NMAP; then
        echo -e "${RED}ERROR: nmap is required but not available${NC}"
        echo -e "${YELLOW}Please install nmap manually and run the script again${NC}"
        exit 1
    fi
    # Get network base from user
    read -p "Enter network base (LIKE THIS. 7 DIGITS EXACT!, 192.168.0): " network_base

    # Validate network base format
    if ! [[ $network_base =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        echo -e "${RED}Invalid network format. Please use format like: 192.168.1${NC}"
        exit 1
    fi

    # Show enhanced menu and handle selection
    show_enhanced_menu

    case $method in
        1)
            ultra_stealth_nmap "$network_base"
            ;;
        2)
            fast_nmap_discovery "$network_base"
            ;;
        3)
            ultra_stealth_nmap "$network_base"
            echo ""
            nmap_port_discovery "$network_base" "stealth"
            ;;
        4)
            fast_nmap_discovery "$network_base"
            echo ""
            nmap_port_discovery "$network_base" "fast"
            ;;
        5)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "stealth" "ipv6,arp,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        6)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "fast" "udp,tcp,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        7)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "fast" "os,service,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        8)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "stealth" "vuln,service,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        9)
            if $V6_MODULE_AVAILABLE; then
                init_v6_module
                enhanced_network_scan "$network_base" "fast" "arp,topology,report"
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        10)
            if $V6_MODULE_AVAILABLE; then
                show_v6_menu
                # Handle v6 menu selection here
            else
                echo -e "${RED}v6module not available${NC}"
            fi
            ;;
        *)
            echo -e "${RED}Invalid option selected${NC}"
            exit 1
            ;;
    esac

    echo ""
    echo -e "${CYAN}üí° Pro Tips:${NC}"
    echo -e "${GREEN}‚Ä¢ Use method 2 for network admin tasks${NC}"
    echo -e "${GREEN}‚Ä¢ Use method 1 for penetration testing${NC}"
    echo -e "${GREEN}‚Ä¢ Run '$SCRIPT_NAME --update' to check for updates${NC}"
    echo -e "${GREEN}‚Ä¢ Visit $GITHUB_URL for documentation${NC}"
    echo ""
    echo -e "${PURPLE}Thank you for using $TOOL_NAME v$TOOL_VERSION by $DEVELOPER${NC}"
}

# Execute main function with all arguments
main "$@"
