#!/usr/bin/env bash

# Color codes for better user experience
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variables to track what we have available
HAVE_NMAP=false
HAVE_FPING=false
HAVE_MASSCAN=false
HAVE_HPING3=false

# Stealth configuration variables
STEALTH_MODE=false
RANDOMIZE_ORDER=true
DECOY_COUNT=3
MIN_DELAY=0.1
MAX_DELAY=0.5

# Function to generate random MAC address for spoofing
generate_random_mac() {
    printf '02:%02x:%02x:%02x:%02x:%02x\n' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# Function to get random delay between probes
get_random_delay() {
    local min_delay=$1
    local max_delay=$2
    # Generate random delay between min and max (in seconds)
    echo "scale=2; $min_delay + ($max_delay - $min_delay) * $RANDOM / 32767" | bc -l 2>/dev/null || echo "$min_delay"
}

# Function to create decoy IP list for nmap
generate_decoys() {
    local network_base="$1"
    local decoy_list=""
    
    for i in $(seq 1 $DECOY_COUNT); do
        # Generate random IP in same subnet but avoid common ranges
        local random_host=$((RANDOM % 254 + 1))
        # Skip common gateway/broadcast ranges
        while [[ $random_host -eq 1 || $random_host -eq 254 || $random_host -eq 255 ]]; do
            random_host=$((RANDOM % 254 + 1))
        done
        
        if [ -n "$decoy_list" ]; then
            decoy_list="${decoy_list},${network_base}.${random_host}"
        else
            decoy_list="${network_base}.${random_host}"
        fi
    done
    
    echo "$decoy_list"
}

# Function to randomize IP order for scanning
randomize_ip_list() {
    local network_base="$1"
    local ip_list=()
    
    # Create array of IPs
    for i in {1..254}; do
        ip_list+=("${network_base}.${i}")
    done
    
    # Shuffle the array using sort with random keys
    printf '%s\n' "${ip_list[@]}" | shuf
}

# Enhanced stealth ping with timing randomization
stealth_ping() {
    local network_base="$1"
    echo -e "${PURPLE}🥷 STEALTH MODE: Using randomized timing and fragmented packets...${NC}"
    echo -e "${CYAN}Techniques: Random delays, packet fragmentation, TTL variation${NC}"
    
    # Create randomized IP list
    local randomized_ips
    if $RANDOMIZE_ORDER; then
        readarray -t randomized_ips < <(randomize_ip_list "$network_base")
    else
        randomized_ips=()
        for i in {1..254}; do
            randomized_ips+=("${network_base}.${i}")
        done
    fi
    
    start_time=$(date +%s)
    local found_hosts=0
    
    for ip in "${randomized_ips[@]}"; do
        # Random delay between probes
        local delay=$(get_random_delay $MIN_DELAY $MAX_DELAY)
        sleep "$delay"
        
        # Use fragmented packets and random TTL to avoid detection
        local ttl=$((32 + RANDOM % 32))  # Random TTL between 32-64
        
        # Fragment the packet and use random packet size
        local packet_size=$((56 + RANDOM % 20))  # Random size 56-76 bytes
        
        if ping -c 1 -W 2 -t "$ttl" -s "$packet_size" -q "$ip" > /dev/null 2>&1; then
            echo -e "${GREEN}🎯 $ip is alive (TTL: $ttl, Size: $packet_size bytes)${NC}"
            ((found_hosts++))
        fi
        
        # Add occasional longer pauses to break patterns
        if (( RANDOM % 20 == 0 )); then
            sleep $(get_random_delay 1.0 3.0)
        fi
    done
    
    end_time=$(date +%s)
    echo -e "${BLUE}Stealth scan completed in $((end_time - start_time)) seconds${NC}"
    echo -e "${GREEN}Found $found_hosts active hosts${NC}"
}

# Ultra-stealth nmap with advanced evasion
stealth_nmap() {
    local network_base="$1"
    echo -e "${PURPLE}🥷 STEALTH NMAP: Using decoys, timing evasion, and fragmentation...${NC}"
    
    # Generate decoy IPs
    local decoys=$(generate_decoys "$network_base")
    echo -e "${CYAN}Using decoy IPs: $decoys${NC}"
    
    start_time=$(date +%s)
    
    # Ultra-stealth nmap command with multiple evasion techniques
    nmap -sn \
         -T1 \
         --randomize-hosts \
         --data-length $((RANDOM % 32 + 16)) \
         --ttl $((32 + RANDOM % 32)) \
         -D "$decoys" \
         --scan-delay $(get_random_delay 0.5 2.0) \
         --max-parallelism 5 \
         --min-parallelism 1 \
         -f \
         --spoof-mac "$(generate_random_mac)" \
         "${network_base}.1-254" 2>/dev/null | \
    grep -E "Nmap scan report for" | \
    awk -v green="$GREEN" -v nc="$NC" '{print green "🎯 " $5 " is alive (stealth mode)" nc}'
    
    end_time=$(date +%s)
    echo -e "${BLUE}Stealth nmap completed in $((end_time - start_time)) seconds${NC}"
}

# Stealth fping with controlled timing
stealth_fping() {
    local network_base="$1"
    echo -e "${PURPLE}🥷 STEALTH FPING: Using controlled intervals and randomization...${NC}"
    
    start_time=$(date +%s)
    
    # Create randomized target list
    local temp_file=$(mktemp)
    randomize_ip_list "$network_base" > "$temp_file"
    
    echo -e "${GREEN}Active hosts found:${NC}"
    
    # Use fping with stealth settings
    fping -f "$temp_file" \
          -r 2 \
          -t 2000 \
          -i $(echo "scale=0; $(get_random_delay 100 500)" | bc -l) \
          -p $(echo "scale=0; $(get_random_delay 500 1500)" | bc -l) \
          -a -q 2>/dev/null | \
    while read host; do
        echo -e "${GREEN}🎯 $host is alive (stealth)${NC}"
        # Small delay between outputs to avoid burst patterns
        sleep $(get_random_delay 0.1 0.3)
    done
    
    rm -f "$temp_file"
    
    end_time=$(date +%s)
    echo -e "${BLUE}Stealth fping completed in $((end_time - start_time)) seconds${NC}"
}

# Advanced stealth masscan with rate limiting
stealth_masscan() {
    local network_base="$1"
    echo -e "${PURPLE}🥷 STEALTH MASSCAN: Using ultra-low rates and randomization...${NC}"
    echo -e "${CYAN}Techniques: Low packet rate, source port randomization, IP randomization${NC}"
    
    start_time=$(date +%s)
    
    # Generate random source port
    local src_port=$((1024 + RANDOM % 64512))
    
    if [ "$EUID" -ne 0 ]; then
        echo -e "${YELLOW}masscan requires root privileges. Running with sudo...${NC}"
        sudo masscan "${network_base}.0/24" \
               --ping \
               --rate 50 \
               --wait 5 \
               --randomize-hosts \
               --source-port "$src_port" \
               --router-mac "$(generate_random_mac)" \
               2>/dev/null | \
        grep -oE "${network_base}\.[0-9]+" | \
        sort -V | uniq | \
        while read host; do
            echo -e "${GREEN}🎯 $host is alive (stealth masscan)${NC}"
            sleep $(get_random_delay 0.2 0.5)
        done
    else
        masscan "${network_base}.0/24" \
               --ping \
               --rate 50 \
               --wait 5 \
               --randomize-hosts \
               --source-port "$src_port" \
               --router-mac "$(generate_random_mac)" \
               2>/dev/null | \
        grep -oE "${network_base}\.[0-9]+" | \
        sort -V | uniq | \
        while read host; do
            echo -e "${GREEN}🎯 $host is alive (stealth masscan)${NC}"
            sleep $(get_random_delay 0.2 0.5)
        done
    fi
    
    end_time=$(date +%s)
    echo -e "${BLUE}Stealth masscan completed in $((end_time - start_time)) seconds${NC}"
}

# Function to detect dependencies including stealth tools
check_and_install_deps() {
    local pkg_manager
    local network_ok=true
    
    echo -e "${BLUE}=== Dependency Check & Auto-Installation ===${NC}"
    
    # Quick network check first
    echo -ne "${BLUE}Checking network connectivity...${NC}"
    if ping -c 1 -W 2 8.8.8.8 &> /dev/null || ping -c 1 -W 2 1.1.1.1 &> /dev/null; then
        echo -e " ${GREEN}✓ Online${NC}"
        network_ok=true
    else
        echo -e " ${RED}✗ Offline${NC}"
        echo -e "${YELLOW}Warning: No internet connection detected. Cannot install missing tools.${NC}"
        network_ok=false
    fi
    
    # Detect package manager
    pkg_manager=$(detect_package_manager)
    if [ "$pkg_manager" = "unknown" ]; then
        echo -e "${YELLOW}Warning: Unknown package manager. Manual installation may be required.${NC}"
    fi
    
    # Check core tools
    local tools=("nmap:nmap" "fping:fping" "masscan:masscan" "hping3:hping3" "bc:bc" "shuf:coreutils")
    
    for tool_info in "${tools[@]}"; do
        IFS=':' read -r tool package <<< "$tool_info"
        echo -ne "${BLUE}Checking $tool...${NC}"
        
        if command -v "$tool" &> /dev/null; then
            echo -e " ${GREEN}✓ Found${NC}"
            case $tool in
                "nmap") HAVE_NMAP=true ;;
                "fping") HAVE_FPING=true ;;
                "masscan") HAVE_MASSCAN=true ;;
                "hping3") HAVE_HPING3=true ;;
            esac
        else
            echo -ne " ${YELLOW}Missing${NC}"
            if $network_ok && [ "$pkg_manager" != "unknown" ]; then
                echo -ne " - Installing..."
                if install_package "$package" "$pkg_manager"; then
                    echo -e " ${GREEN}✓ Installed${NC}"
                    case $tool in
                        "nmap") HAVE_NMAP=true ;;
                        "fping") HAVE_FPING=true ;;
                        "masscan") HAVE_MASSCAN=true ;;
                        "hping3") HAVE_HPING3=true ;;
                    esac
                else
                    echo -e " ${RED}✗ Failed${NC}"
                fi
            else
                echo -e " ${RED}✗ Cannot install${NC}"
            fi
        fi
    done
    
    echo ""
}

# Function to detect the package manager and OS
detect_package_manager() {
    if command -v apt-get &> /dev/null; then
        echo "apt"
    elif command -v yum &> /dev/null; then
        echo "yum"
    elif command -v dnf &> /dev/null; then
        echo "dnf"
    elif command -v pacman &> /dev/null; then
        echo "pacman"
    elif command -v zypper &> /dev/null; then
        echo "zypper"
    elif command -v apk &> /dev/null; then
        echo "apk"
    else
        echo "unknown"
    fi
}

# Function to install a package based on the detected package manager
install_package() {
    local package_name="$1"
    local pkg_manager="$2"
    
    case $pkg_manager in
        "apt")
            sudo apt-get update &> /dev/null && sudo apt-get install -y "$package_name" &> /dev/null
            ;;
        "yum")
            sudo yum install -y "$package_name" &> /dev/null
            ;;
        "dnf")
            sudo dnf install -y "$package_name" &> /dev/null
            ;;
        "pacman")
            sudo pacman -Sy --noconfirm "$package_name" &> /dev/null
            ;;
        "zypper")
            sudo zypper install -y "$package_name" &> /dev/null
            ;;
        "apk")
            sudo apk add "$package_name" &> /dev/null
            ;;
        *)
            return 1
            ;;
    esac
}

# Enhanced menu with stealth options
show_stealth_menu() {
    echo -e "${PURPLE}=== 🥷 STEALTH Network Sweeper - Maximum Evasion ===${NC}"
    echo -e "${CYAN}Stealth Features: Randomized timing, packet fragmentation, decoy IPs${NC}"
    echo ""
    echo "1. Stealth ping sweep (randomized timing + fragmentation)"
    echo "2. Original optimized ping (fast but detectable)"
    echo "3. Original batch parallel (medium speed)"
    
    local option_counter=4
    
    if $HAVE_NMAP; then
        echo "$option_counter. 🥷 Ultra-stealth nmap (decoys + evasion) ${GREEN}[Available]${NC}"
        STEALTH_NMAP_OPTION=$option_counter
        ((option_counter++))
        echo "$option_counter. Original nmap scan (fast but detectable) ${GREEN}[Available]${NC}"
        NMAP_OPTION=$option_counter
        ((option_counter++))
    else
        echo "X. Ultra-stealth nmap scan ${RED}[Not Available]${NC}"
        echo "X. Original nmap scan ${RED}[Not Available]${NC}"
    fi
    
    if $HAVE_FPING; then
        echo "$option_counter. 🥷 Stealth fping (controlled timing) ${GREEN}[Available]${NC}"
        STEALTH_FPING_OPTION=$option_counter
        ((option_counter++))
        echo "$option_counter. Original fping (lightning fast) ${GREEN}[Available]${NC}"
        FPING_OPTION=$option_counter
        ((option_counter++))
    else
        echo "X. Stealth fping ${RED}[Not Available]${NC}"
        echo "X. Original fping ${RED}[Not Available]${NC}"
    fi
    
    if $HAVE_MASSCAN; then
        echo "$option_counter. 🥷 Stealth masscan (ultra-low rate) ${GREEN}[Available]${NC}"
        STEALTH_MASSCAN_OPTION=$option_counter
        ((option_counter++))
        echo "$option_counter. Original masscan (extreme speed) ${GREEN}[Available]${NC}"
        MASSCAN_OPTION=$option_counter
        ((option_counter++))
    else
        echo "X. Stealth masscan ${RED}[Not Available]${NC}"
        echo "X. Original masscan ${RED}[Not Available]${NC}"
    fi
    
    echo ""
    echo -e "${YELLOW}Stealth Configuration:${NC}"
    echo "• Randomize scan order: $RANDOMIZE_ORDER"
    echo "• Decoy count: $DECOY_COUNT"
    echo "• Delay range: ${MIN_DELAY}s - ${MAX_DELAY}s"
    echo ""
    read -p "Select method (1-$((option_counter-1))): " method
}

# [Previous scanning functions remain the same - optimized_ping, batch_parallel, nmap_scan, fping_scan, masscan_scan]

# Original functions for comparison
optimized_ping() {
    local network_base="$1"
    echo -e "${BLUE}Using optimized ping with aggressive timeouts...${NC}"
    
    fast_ping() {
        local ip=$1
        if ping -c 1 -W 1 -q "$ip" > /dev/null 2>&1; then
            echo -e "${GREEN}$ip is alive${NC}"
        fi
    }
    
    start_time=$(date +%s)
    for i in {1..254}; do
        fast_ping "${network_base}.${i}" &
    done
    wait
    end_time=$(date +%s)
    echo -e "${BLUE}Scan completed in $((end_time - start_time)) seconds${NC}"
}

batch_parallel() {
    local network_base="$1"
    echo -e "${BLUE}Using controlled concurrency to prevent system overload...${NC}"
    
    scan_batch() {
        local start=$1
        local end=$2
        for i in $(seq $start $end); do
            if ping -c 1 -W 1 -q "${network_base}.${i}" > /dev/null 2>&1; then
                echo -e "${GREEN}${network_base}.${i} is alive${NC}"
            fi
        done
    }
    
    start_time=$(date +%s)
    batch_size=25
    
    for batch_start in $(seq 1 $batch_size 254); do
        batch_end=$((batch_start + batch_size - 1))
        if [ $batch_end -gt 254 ]; then
            batch_end=254
        fi
        scan_batch $batch_start $batch_end &
    done
    
    wait
    end_time=$(date +%s)
    echo -e "${BLUE}Batch scan completed in $((end_time - start_time)) seconds${NC}"
}

nmap_scan() {
    local network_base="$1"
    echo -e "${BLUE}Using nmap for professional-grade network discovery...${NC}"
    
    start_time=$(date +%s)
    nmap -sn -T5 --min-parallelism 100 --max-parallelism 255 "${network_base}.1-254" 2>/dev/null | \
    grep -E "Nmap scan report for" | \
    awk -v green="$GREEN" -v nc="$NC" '{print green $5 " is alive" nc}'
    
    end_time=$(date +%s)
    echo -e "${BLUE}nmap scan completed in $((end_time - start_time)) seconds${NC}"
}

fping_scan() {
    local network_base="$1"
    echo -e "${BLUE}Using fping - the parallel ping specialist...${NC}"
    
    start_time=$(date +%s)
    echo -e "${GREEN}Active hosts found:${NC}"
    fping -g -r 1 -t 100 -a -q "${network_base}.1" "${network_base}.254" 2>/dev/null | \
    while read host; do
        echo -e "${GREEN}$host is alive${NC}"
    done
    
    end_time=$(date +%s)
    echo -e "${BLUE}fping scan completed in $((end_time - start_time)) seconds${NC}"
}

masscan_scan() {
    local network_base="$1"
    echo -e "${BLUE}Using masscan - the extreme speed scanner...${NC}"
    echo -e "${YELLOW}Note: This will perform a ping scan using ICMP${NC}"
    
    start_time=$(date +%s)
    
    if [ "$EUID" -ne 0 ]; then
        echo -e "${YELLOW}masscan requires root privileges. Running with sudo...${NC}"
        sudo masscan "${network_base}.0/24" --ping --rate 1000 --wait 2 2>/dev/null | \
        grep -oE "${network_base}\.[0-9]+" | \
        sort -V | uniq | \
        while read host; do
            echo -e "${GREEN}$host is alive${NC}"
        done
    else
        masscan "${network_base}.0/24" --ping --rate 1000 --wait 2 2>/dev/null | \
        grep -oE "${network_base}\.[0-9]+" | \
        sort -V | uniq | \
        while read host; do
            echo -e "${GREEN}$host is alive${NC}"
        done
    fi
    
    end_time=$(date +%s)
    echo -e "${BLUE}masscan completed in $((end_time - start_time)) seconds${NC}"
}

# Main execution starts here
clear
echo -e "${PURPLE}╔════════════════════════════════════════════╗${NC}"
echo -e "${PURPLE}║   🥷 huntr Network IP Stealth Sweeper     ║${NC}"
echo -e "${PURPLE}║   by 0xb0rn3 | oxbv1 IG: theehiv3         ║${NC}"
echo -e "${PURPLE}║   Enhanced with Maximum Stealth Features  ║${NC}"
echo -e "${PURPLE}╚════════════════════════════════════════════╝${NC}"
echo ""

# Check and install dependencies
check_and_install_deps

# Get network base from user
read -p "Enter network base (e.g., 192.168.1): " network_base

# Validate network base format
if ! [[ $network_base =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    echo -e "${RED}Invalid network format. Please use format like: 192.168.1${NC}"
    exit 1
fi

# Show stealth menu and handle selection
show_stealth_menu

case $method in
    1)
        stealth_ping "$network_base"
        ;;
    2)
        optimized_ping "$network_base"
        ;;
    3)
        batch_parallel "$network_base"
        ;;
    "$STEALTH_NMAP_OPTION")
        if $HAVE_NMAP; then
            stealth_nmap "$network_base"
        else
            echo -e "${RED}nmap is not available${NC}"
            exit 1
        fi
        ;;
    "$NMAP_OPTION")
        if $HAVE_NMAP; then
            nmap_scan "$network_base"
        else
            echo -e "${RED}nmap is not available${NC}"
            exit 1
        fi
        ;;
    "$STEALTH_FPING_OPTION")
        if $HAVE_FPING; then
            stealth_fping "$network_base"
        else
            echo -e "${RED}fping is not available${NC}"
            exit 1
        fi
        ;;
    "$FPING_OPTION")
        if $HAVE_FPING; then
            fping_scan "$network_base"
        else
            echo -e "${RED}fping is not available${NC}"
            exit 1
        fi
        ;;
    "$STEALTH_MASSCAN_OPTION")
        if $HAVE_MASSCAN; then
            stealth_masscan "$network_base"
        else
            echo -e "${RED}masscan is not available${NC}"
            exit 1
        fi
        ;;
    "$MASSCAN_OPTION")
        if $HAVE_MASSCAN; then
            masscan_scan "$network_base"
        else
            echo -e "${RED}masscan is not available${NC}"
            exit 1
        fi
        ;;
    *)
        echo -e "${RED}Invalid option selected${NC}"
        exit 1
        ;;
esac

echo ""
echo -e "${PURPLE}=== 🥷 Stealth Performance Guide ===${NC}"
echo -e "${GREEN}Stealth Level:${NC} stealth_ping > stealth_nmap > stealth_fping > stealth_masscan"
echo -e "${GREEN}Speed vs Stealth:${NC} Higher stealth = Lower speed but much harder to detect"
echo -e "${GREEN}Detection Avoidance:${NC} Randomized timing, packet fragmentation, decoy IPs"
echo -e "${YELLOW}Pro Tip:${NC} Use stealth modes for penetration testing, regular modes for network admin tasks"
